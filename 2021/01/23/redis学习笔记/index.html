<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="XIYUE"><meta name="copyright" content="XIYUE"><meta name="generator" content="Hexo 5.3.0"><meta name="theme" content="hexo-theme-yun"><title>redis学习笔记 | XIYUEBlog</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.22/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"mikon.github.io","root":"/","title":"曦月君的小站","version":"1.3.0","mode":"auto","copycode":true,"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><meta name="description" content="redis学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="redis学习笔记">
<meta property="og:url" content="http://mikon.github.io/2021/01/23/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="XIYUEBlog">
<meta property="og:description" content="redis学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.ax1x.com/2021/01/17/srT8iV.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/01/17/srohCT.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QZHaR.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QZOG6.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QeFit.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QeARf.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QemLQ.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6Qe8zT.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QeYyF.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6Qe6yD.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QeWTA.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QeoSf.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QeLwj.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6Qm17d.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6Qmb36.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QngIA.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QnfRP.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6Qnoqg.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QuesO.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QuKdH.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QKp1P.jpg">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QKb3q.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QKqg0.jpg">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6Q8lB6.jpg">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6Q84bV.jpg">
<meta property="og:image" content="https://s3.ax1x.com/2021/03/08/6QGp5D.jpg">
<meta property="article:published_time" content="2021-01-23T12:00:00.000Z">
<meta property="article:modified_time" content="2021-03-08T02:44:41.923Z">
<meta property="article:author" content="XIYUE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.ax1x.com/2021/01/17/srT8iV.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="XIYUE"><img width="96" loading="lazy" src="https://xiyuexiaozhan-1258651455.cos.ap-nanjing.myqcloud.com/avatar.jpg" alt="XIYUE"></a><div class="site-author-name"><a href="/about/">XIYUE</a></div><a class="site-name" href="/about/site.html">XIYUEBlog</a><sub class="site-subtitle">早睡身体健康</sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">12</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">4</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://xiyuexiaozhan.com" title="主页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/mikontop" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/5272062427" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=413010776" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/xi-yue-50-20-57" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/18643578" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/gjy1192112668" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%88%86%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">NoSQL数据库的四大分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93CAP%E5%8E%9F%E7%90%86-BASE"><span class="toc-number">2.</span> <span class="toc-text">分布式数据库CAP原理+BASE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8CAP%E5%9B%BE"><span class="toc-number">2.1.</span> <span class="toc-text">经典CAP图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BASE"><span class="toc-number">2.2.</span> <span class="toc-text">BASE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-%E9%9B%86%E7%BE%A4%E7%AE%80%E4%BB%8B"><span class="toc-number">2.3.</span> <span class="toc-text">分布式+集群简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">3.</span> <span class="toc-text">安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">入门概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-number">3.1.2.</span> <span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E5%93%AA%E4%B8%8B"><span class="toc-number">3.1.3.</span> <span class="toc-text">去哪下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%8E%A9"><span class="toc-number">3.1.4.</span> <span class="toc-text">怎么玩</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">3.2.</span> <span class="toc-text">Redis的安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E7%89%88%E5%AE%89%E8%A3%85"><span class="toc-number">3.2.1.</span> <span class="toc-text">Linux版安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows%E7%89%88%E5%AE%89%E8%A3%85"><span class="toc-number">3.2.2.</span> <span class="toc-text">Windows版安装</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HelloWorld"><span class="toc-number">4.</span> <span class="toc-text">HelloWorld</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%90%8E%E6%9D%82%E9%A1%B9%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.</span> <span class="toc-text">启动后杂项基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">6.</span> <span class="toc-text">常用五大数据类型简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">Redis的五大数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.</span> <span class="toc-text">Key关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84"><span class="toc-number">7.1.</span> <span class="toc-text">常用的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">7.1.1.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">8.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8"><span class="toc-number">8.1.</span> <span class="toc-text">常用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-number">8.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">9.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-1"><span class="toc-number">9.1.</span> <span class="toc-text">常用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-number">9.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">10.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-2"><span class="toc-number">10.1.</span> <span class="toc-text">常用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-3"><span class="toc-number">10.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash"><span class="toc-number">11.</span> <span class="toc-text">Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-3"><span class="toc-number">11.1.</span> <span class="toc-text">常用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-4"><span class="toc-number">11.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZSet"><span class="toc-number">12.</span> <span class="toc-text">ZSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-4"><span class="toc-number">12.1.</span> <span class="toc-text">常用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-5"><span class="toc-number">12.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">13.</span> <span class="toc-text">配置文件介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">13.1.</span> <span class="toc-text">参数说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB"><span class="toc-number">14.</span> <span class="toc-text">持久化之RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">14.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91RDB%E5%BF%AB%E7%85%A7"><span class="toc-number">14.2.</span> <span class="toc-text">如何触发RDB快照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D"><span class="toc-number">14.3.</span> <span class="toc-text">如何恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="toc-number">14.4.</span> <span class="toc-text">优势与劣势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2"><span class="toc-number">14.5.</span> <span class="toc-text">如何停止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">14.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BAOF"><span class="toc-number">15.</span> <span class="toc-text">持久化之AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-number">15.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E9%85%8D%E7%BD%AE"><span class="toc-number">15.2.</span> <span class="toc-text">AOF配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E5%90%AF%E5%8A%A8-%E4%BF%AE%E5%A4%8D-%E6%81%A2%E5%A4%8D"><span class="toc-number">15.3.</span> <span class="toc-text">AOF启动&#x2F;修复&#x2F;恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rewrite"><span class="toc-number">15.4.</span> <span class="toc-text">rewrite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF-1"><span class="toc-number">15.5.</span> <span class="toc-text">优势与劣势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">15.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">16.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="toc-number">16.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B-1"><span class="toc-number">16.2.</span> <span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%8E%A9-1"><span class="toc-number">16.3.</span> <span class="toc-text">怎么玩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">16.3.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Case"><span class="toc-number">16.3.2.</span> <span class="toc-text">Case</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C"><span class="toc-number">16.3.2.1.</span> <span class="toc-text">正常执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BE%E5%BC%83%E4%BA%8B%E5%8A%A1"><span class="toc-number">16.3.2.2.</span> <span class="toc-text">放弃事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E4%BD%93%E8%BF%9E%E5%9D%90"><span class="toc-number">16.3.2.3.</span> <span class="toc-text">全体连坐</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%A4%E5%A4%B4%E5%80%BA%E4%B8%BB"><span class="toc-number">16.3.2.4.</span> <span class="toc-text">冤头债主</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#watch%E7%9B%91%E6%8E%A7"><span class="toc-number">16.3.2.5.</span> <span class="toc-text">watch监控</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81-%E4%B9%90%E8%A7%82%E9%94%81-CAS-Check-And-Set"><span class="toc-number">16.3.2.5.1.</span> <span class="toc-text">悲观锁&#x2F;乐观锁&#x2F;CAS(Check And Set)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%A1%E7%94%A8%E5%8D%A1%E5%8F%AF%E7%94%A8%E4%BD%99%E9%A2%9D%E5%92%8C%E6%AC%A0%E9%A2%9D"><span class="toc-number">16.3.2.5.2.</span> <span class="toc-text">信用卡可用余额和欠额</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">16.3.2.5.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E9%98%B6%E6%AE%B5"><span class="toc-number">16.4.</span> <span class="toc-text">3阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E7%89%B9%E6%80%A7"><span class="toc-number">16.5.</span> <span class="toc-text">3特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E7%AE%80%E4%BB%8B"><span class="toc-number">17.</span> <span class="toc-text">消息订阅发布简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1"><span class="toc-number">17.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">17.2.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">18.</span> <span class="toc-text">主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-4"><span class="toc-number">18.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B-2"><span class="toc-number">18.2.</span> <span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%8E%A9-2"><span class="toc-number">18.3.</span> <span class="toc-text">怎么玩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">18.3.1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A83%E6%8B%9B"><span class="toc-number">18.3.2.</span> <span class="toc-text">常用3招</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%86"><span class="toc-number">18.3.2.1.</span> <span class="toc-text">一主二仆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-number">18.3.2.2.</span> <span class="toc-text">薪火相传</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="toc-number">18.3.2.3.</span> <span class="toc-text">反客为主</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">18.4.</span> <span class="toc-text">复制的缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number"></span> <span class="toc-text">缓存三大问题及解决方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number"></span> <span class="toc-text">1. 缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1.1 什么是缓存穿透？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="toc-number">2.</span> <span class="toc-text">1.2 缓存穿透的危害</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">1.3 为什么会发生缓存穿透？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.</span> <span class="toc-text">1.4 缓存穿透的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E7%BC%93%E5%AD%98%E7%A9%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">4.1.</span> <span class="toc-text">1.4.1 缓存空数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-BloomFilter"><span class="toc-number">4.2.</span> <span class="toc-text">1.4.2 BloomFilter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.3.</span> <span class="toc-text">1.4.3 两种方案的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number"></span> <span class="toc-text">2. 缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">2.1 什么是缓存雪崩？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2.2 如何避免缓存雪崩？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E9%9B%86%E7%BE%A4%EF%BC%8C%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">2.2.1 使用缓存集群，保证缓存高可用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E4%BD%BF%E7%94%A8Hystrix"><span class="toc-number">2.2.</span> <span class="toc-text">2.2.2 使用Hystrix</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%88%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%AD%E5%A4%B1%E6%95%88%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">3. 缓存击穿（热点数据集中失效）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%AD%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">3.1 什么是热点数据集中失效？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.</span> <span class="toc-text">3.2 解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">2.1.</span> <span class="toc-text">3.2.1 互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%BF%87%E6%9C%9F"><span class="toc-number">2.2.</span> <span class="toc-text">3.3.2 永远不过期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.3.</span> <span class="toc-text">3.3.3 两种方案的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">3.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://mikon.github.io/2021/01/23/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="XIYUE"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="XIYUEBlog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">redis学习笔记</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-01-23 20:00:00" itemprop="dateCreated datePublished" datetime="2021-01-23T20:00:00+08:00">2021-01-23</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-03-08 10:44:41" itemprop="dateModified" datetime="2021-03-08T10:44:41+08:00">2021-03-08</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/code/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">code</span></a></span></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h2 id="NoSQL数据库的四大分类"><a href="#NoSQL数据库的四大分类" class="headerlink" title="NoSQL数据库的四大分类"></a>NoSQL数据库的四大分类</h2><ul>
<li><p>KV</p>
<ul>
<li>新浪：BerkeleyDB + Redis</li>
<li>美团：Redis + tair</li>
<li>阿里、百度：memcache + Redis</li>
</ul>
</li>
<li><p>文档型数据库（bson格式比较多）</p>
<ul>
<li>CouchDB</li>
<li>MongoDB<ul>
<li>MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。</li>
<li>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</li>
</ul>
</li>
</ul>
</li>
<li><p>列存储数据库</p>
<ul>
<li>Cassandra、HBase</li>
<li>分布式文件系统</li>
</ul>
</li>
<li><p>图关系数据库</p>
<ul>
<li>它不是放图形的、放的是关系比如：朋友圈社交网络、广告推荐系统</li>
<li>社交网络、推荐系统。专注于构建关系图谱</li>
<li>Neo4j、InfoGrid</li>
</ul>
</li>
<li><p>四者对比</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/srT8iV"><img src="https://s3.ax1x.com/2021/01/17/srT8iV.png" alt="srT8iV.png" loading="lazy"></a></p>
</li>
</ul>
<h2 id="分布式数据库CAP原理-BASE"><a href="#分布式数据库CAP原理-BASE" class="headerlink" title="分布式数据库CAP原理+BASE"></a>分布式数据库CAP原理+BASE</h2><p>强一致性（Consistency）</p>
<p>可用性（Availability）</p>
<p>分区容错性（Partition tolerance）</p>
<p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求</p>
<p>而由于当前的网络硬件肯定会出现延迟丢包等问题，所以<strong>分区容忍性</strong>是我们必须需要实现的。所以我们只能在<strong>一致性</strong>和<strong>可用性</strong>之间进行权衡，<strong>没有</strong>NoSQL系统能同时保证这三点。</p>
<ul>
<li><p>CA 传统Oracle数据库</p>
</li>
<li><p>AP 大多数网站架构的选择</p>
</li>
<li><p>CP Redis、Mongodb</p>
<h3 id="经典CAP图"><a href="#经典CAP图" class="headerlink" title="经典CAP图"></a>经典CAP图</h3><p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，<strong>最多只能同时较好的满足两个</strong>。</p>
<p>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：</p>
<ul>
<li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li>
<li>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。</li>
<li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/srohCT"><img src="https://s3.ax1x.com/2021/01/17/srohCT.png" alt="srohCT.png" loading="lazy"></a></p>
<h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p>
<p>BASE其实是下面三个术语的缩写：</p>
<ul>
<li>基本可用（Basically Available）</li>
<li>软状态（Soft state）</li>
<li>最终一致（Eventually consistent）</li>
</ul>
<p>它的思想是通过<strong>让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观</strong>。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法</p>
<h3 id="分布式-集群简介"><a href="#分布式-集群简介" class="headerlink" title="分布式+集群简介"></a>分布式+集群简介</h3><p>分布式系统（distributed system）</p>
<p>由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。分布式系统可以应用在在不同的平台上如：PC、工作站、局域网和广域网上等。</p>
<p>简单来讲：</p>
<ol>
<li>分布式：不同的多台服务器上面部署<strong>不同</strong>的服务模块（工程），他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作。</li>
<li>集群：不同的多台服务器上面部署<strong>相同</strong>的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="入门概述"><a href="#入门概述" class="headerlink" title="入门概述"></a>入门概述</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>Redis:REmote DIctionary Server(远程字典服务器)是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行 并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构服务器。</p>
<p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份</li>
</ul>
<h4 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h4><ul>
<li>内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务</li>
<li>取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面</li>
<li>模拟类似于HttpSession这种需要设定过期时间的功能</li>
<li>发布、订阅消息系统</li>
<li>定时器、计数器</li>
</ul>
<h4 id="去哪下"><a href="#去哪下" class="headerlink" title="去哪下"></a>去哪下</h4><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis官网</a></li>
<li><a target="_blank" rel="noopener" href="http://www.redis.cn/">Redis中文网</a></li>
</ul>
<h4 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h4><ul>
<li>数据类型、基本操作和配置</li>
<li>持久化和复制，RDB/AOF</li>
<li>事务的控制</li>
<li>复制（主从关系）</li>
</ul>
<h3 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h3><h4 id="Linux版安装"><a href="#Linux版安装" class="headerlink" title="Linux版安装"></a>Linux版安装</h4><p>略</p>
<h4 id="Windows版安装"><a href="#Windows版安装" class="headerlink" title="Windows版安装"></a>Windows版安装</h4><p><a target="_blank" rel="noopener" href="https://github.com/tporadowski/redis/releases">Redis X.X.X for Windows</a></p>
<p>大多数企业是使用Linux的Redis，Windows仅供学习。</p>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><ol>
<li>打开cmd</li>
<li>输入<code>cd C:\Program Files\Redis-x64-3.2.100</code>，进入Redis的主目录</li>
<li>输入<code>redis-server.exe redis.windows.conf</code>，打开Redis服务端</li>
<li>另外打开cmd</li>
<li>输入<code>cd C:\Program Files\Redis-x64-3.2.100</code>，进入Redis的主目录</li>
<li>输入<code>redis-cli.exe -h 127.0.0.1 -p 6379</code>，打开Redis客户端</li>
<li>在Redis客户端输入<code>set hello world</code>回车，再输入<code>get hello</code>回车便返回<code>world</code>。</li>
<li>在Redis客户端输入<code>exit</code>回车、退出客户端。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Redis-x64-3.2.100&gt;redis-cli.exe</span><br><span class="line">127.0.0.1:6379&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<h2 id="启动后杂项基础知识"><a href="#启动后杂项基础知识" class="headerlink" title="启动后杂项基础知识"></a>启动后杂项基础知识</h2><ul>
<li><code>C:\Program Files\Redis-x64-3.2.100&gt;redis-benchmark.exe</code> 测试redis在机器运行的效能</li>
<li>单进程<ul>
<li>单进程模型来处理客户端的请求。对读写等事件的响应 是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率</li>
<li>Epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本， 它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</li>
</ul>
</li>
<li>默认16个数据库，类似数组下表从零开始，初始默认使用零号库，可在配置文件配置</li>
<li><code>select</code>命令切换数据库</li>
<li><code>dbsize</code>查看当前数据库的key的数量</li>
<li><code>flushdb</code>：清空当前库</li>
<li><code>flushall</code>；通杀全部库</li>
<li>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上</li>
<li>Redis索引都是从零开始</li>
<li>为什么默认端口是6379</li>
</ul>
<h2 id="常用五大数据类型简介"><a href="#常用五大数据类型简介" class="headerlink" title="常用五大数据类型简介"></a>常用五大数据类型简介</h2><h3 id="Redis的五大数据类型"><a href="#Redis的五大数据类型" class="headerlink" title="Redis的五大数据类型"></a>Redis的五大数据类型</h3><ul>
<li>String（字符串）<ul>
<li>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</li>
<li>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</li>
<li>string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M</li>
</ul>
</li>
<li>Hash（哈希，类似java里的Map）<ul>
<li>Redis hash 是一个键值对集合。</li>
<li>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</li>
<li>类似Java里面的Map&lt;String,Object&gt;</li>
</ul>
</li>
<li>List（列表）<ul>
<li>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。</li>
<li>它的底层实际是个链表</li>
</ul>
</li>
<li>Set（集合）<ul>
<li>Redis的Set是string类型的无序集合。它是通过HashTable实现实现的</li>
</ul>
</li>
<li>Zset(sorted set：有序集合)<ul>
<li>Redis zset 和 set 一样也是string类型元素的集合，且不允许重复的成员。</li>
<li>不同的是每个元素都会关联一个double类型的分数。</li>
<li>redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数(score)却可以重复。</li>
</ul>
</li>
<li>哪里去获得redis常见数据类型操作命令<ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis 命令参考</a></li>
<li><a target="_blank" rel="noopener" href="https://redis.io/commands">Redis 官网命令参考</a></li>
</ul>
</li>
</ul>
<h2 id="Key关键字"><a href="#Key关键字" class="headerlink" title="Key关键字"></a>Key关键字</h2><h3 id="常用的"><a href="#常用的" class="headerlink" title="常用的"></a>常用的</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEL key</td>
<td>该命令用于在 key 存在时删除 key。</td>
</tr>
<tr>
<td>DUMP key</td>
<td>序列化给定 key ，并返回被序列化的值。</td>
</tr>
<tr>
<td>EXISTS key</td>
<td>检查给定 key 是否存在。</td>
</tr>
<tr>
<td>EXPIRE key seconds</td>
<td>为给定 key 设置过期时间，以秒计。</td>
</tr>
<tr>
<td>EXPIREAT key timestamp</td>
<td>EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td>
</tr>
<tr>
<td>PEXPIRE key milliseconds</td>
<td>设置 key 的过期时间以毫秒计。</td>
</tr>
<tr>
<td>PEXPIREAT key milliseconds-timestamp</td>
<td>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td>
</tr>
<tr>
<td>KEYS pattern</td>
<td>查找所有符合给定模式( pattern)的 key 。</td>
</tr>
<tr>
<td>MOVE key db</td>
<td>将当前数据库的 key 移动到给定的数据库 db 当中。</td>
</tr>
<tr>
<td>PERSIST key</td>
<td>移除 key 的过期时间，key 将持久保持。</td>
</tr>
<tr>
<td>PTTL key</td>
<td>以毫秒为单位返回 key 的剩余的过期时间。</td>
</tr>
<tr>
<td>TTL key</td>
<td>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</td>
</tr>
<tr>
<td>RANDOMKEY</td>
<td>从当前数据库中随机返回一个 key 。</td>
</tr>
<tr>
<td>RENAME key newkey</td>
<td>修改 key 的名称</td>
</tr>
<tr>
<td>RENAMENX key newkey</td>
<td>仅当 newkey 不存在时，将 key 改名为 newkey 。</td>
</tr>
<tr>
<td>SCAN cursor [MATCH pattern] [COUNT count]</td>
<td>迭代数据库中的数据库键。</td>
</tr>
<tr>
<td>TYPE key</td>
<td>返回 key 所储存的值的类型。</td>
</tr>
</tbody></table>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul>
<li>keys *</li>
<li>exists key的名字，判断某个key是否存在</li>
<li>move key db —&gt;当前库就没有了，被移除了</li>
<li>expire key 秒钟：为给定的key设置过期时间</li>
<li>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li>
<li>type key 查看你的key是什么类型</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>单值单value</p>
<h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SET key value</td>
<td>设置指定 key 的值</td>
</tr>
<tr>
<td>GET key</td>
<td>获取指定 key 的值。</td>
</tr>
<tr>
<td>GETRANGE key start end</td>
<td>返回 key 中字符串值的子字符</td>
</tr>
<tr>
<td>GETSET key value</td>
<td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>
</tr>
<tr>
<td>GETBIT key offset</td>
<td>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td>MGET key1 [key2…]</td>
<td>获取所有(一个或多个)给定 key 的值。</td>
</tr>
<tr>
<td>SETBIT key offset value</td>
<td>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td>SETEX key seconds value</td>
<td>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td>
</tr>
<tr>
<td>SETNX key value</td>
<td>只有在 key 不存在时设置 key 的值。</td>
</tr>
<tr>
<td>SETRANGE key offset value</td>
<td>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td>
</tr>
<tr>
<td>STRLEN key</td>
<td>返回 key 所储存的字符串值的长度。</td>
</tr>
<tr>
<td>MSET key value [key value …]</td>
<td>同时设置一个或多个 key-value 对。</td>
</tr>
<tr>
<td>MSETNX key value [key value …]</td>
<td>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td>
</tr>
<tr>
<td>PSETEX key milliseconds value</td>
<td>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td>
</tr>
<tr>
<td>INCR key</td>
<td>将 key 中储存的数字值增一。</td>
</tr>
<tr>
<td>INCRBY key increment</td>
<td>将 key 所储存的值加上给定的增量值（increment） 。</td>
</tr>
<tr>
<td>INCRBYFLOAT key increment</td>
<td>将 key 所储存的值加上给定的浮点增量值（increment） 。</td>
</tr>
<tr>
<td>DECR key</td>
<td>将 key 中储存的数字值减一。</td>
</tr>
<tr>
<td>DECRBY key decrement</td>
<td>key 所储存的值减去给定的减量值（decrement） 。</td>
</tr>
<tr>
<td>APPEND key value</td>
<td>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</td>
</tr>
</tbody></table>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><ul>
<li>set/get/del/append/strlen</li>
<li>Incr/decr/incrby/decrby,一定要是数字才能进行加减</li>
<li>getrange/setrange</li>
<li>setex(set with expire)键秒值/setnx(set if not exist)</li>
<li>mset/mget/msetnx</li>
<li>getset(先get再set)</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>单值多value</p>
<h3 id="常用-1"><a href="#常用-1" class="headerlink" title="常用"></a>常用</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BLPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>BRPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>BRPOPLPUSH source destination timeout</td>
<td>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>LINDEX key index</td>
<td>通过索引获取列表中的元素</td>
</tr>
<tr>
<td>LINSERT key BEFORE/AFTER pivot value</td>
<td>在列表的元素前或者后插入元素</td>
</tr>
<tr>
<td>LLEN key</td>
<td>获取列表长度</td>
</tr>
<tr>
<td>LPOP key</td>
<td>移出并获取列表的第一个元素</td>
</tr>
<tr>
<td>LPUSH key value1 [value2]</td>
<td>将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td>LPUSHX key value</td>
<td>将一个值插入到已存在的列表头部</td>
</tr>
<tr>
<td>LRANGE key start stop</td>
<td>获取列表指定范围内的元素</td>
</tr>
<tr>
<td>LREM key count value</td>
<td>移除列表元素</td>
</tr>
<tr>
<td>LSET key index value</td>
<td>通过索引设置列表元素的值</td>
</tr>
<tr>
<td>LTRIM key start stop</td>
<td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td>
</tr>
<tr>
<td>RPOP key</td>
<td>移除列表的最后一个元素，返回值为移除的元素。</td>
</tr>
<tr>
<td>RPOPLPUSH source destination</td>
<td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td>RPUSH key value1 [value2]</td>
<td>在列表中添加一个或多个值</td>
</tr>
<tr>
<td>RPUSHX key value</td>
<td>为已存在的列表添加值</td>
</tr>
</tbody></table>
<h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><ul>
<li>lpush/rpush/lrange</li>
<li>lpop/rpop</li>
<li>lindex，按照索引下标获得元素(从上到下)</li>
<li>llen</li>
<li>lrem key 删N个value</li>
<li>ltrim key 开始index 结束index，截取指定范围的值后再赋值给key</li>
<li>rpoplpush 源列表 目的列表</li>
<li>lset key index value</li>
<li>linsert key before/after 值1 值2</li>
</ul>
<p>性能总结：</p>
<ul>
<li>它是一个字符串链表，left、right都可以插入添加；</li>
<li>如果键不存在，创建新的链表；</li>
<li>如果键已存在，新增内容；</li>
<li>如果值全移除，对应的键也就消失了。</li>
<li>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>单值多value</p>
<h3 id="常用-2"><a href="#常用-2" class="headerlink" title="常用"></a>常用</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SADD key member1 [member2]</td>
<td>向集合添加一个或多个成员</td>
</tr>
<tr>
<td>SCARD key</td>
<td>获取集合的成员数</td>
</tr>
<tr>
<td>SDIFF key1 [key2]</td>
<td>返回给定所有集合的差集</td>
</tr>
<tr>
<td>SDIFFSTORE destination key1 [key2]</td>
<td>返回给定所有集合的差集并存储在 destination 中</td>
</tr>
<tr>
<td>SINTER key1 [key2]</td>
<td>返回给定所有集合的交集</td>
</tr>
<tr>
<td>SINTERSTORE destination key1 [key2]</td>
<td>返回给定所有集合的交集并存储在 destination 中</td>
</tr>
<tr>
<td>SISMEMBER key member</td>
<td>判断 member 元素是否是集合 key 的成员</td>
</tr>
<tr>
<td>SMEMBERS key</td>
<td>返回集合中的所有成员</td>
</tr>
<tr>
<td>SMOVE source destination member</td>
<td>将 member 元素从 source 集合移动到 destination 集合</td>
</tr>
<tr>
<td>SPOP key</td>
<td>移除并返回集合中的一个随机元素</td>
</tr>
<tr>
<td>SRANDMEMBER key [count]</td>
<td>返回集合中一个或多个随机数</td>
</tr>
<tr>
<td>SREM key member1 [member2]</td>
<td>移除集合中一个或多个成员</td>
</tr>
<tr>
<td>SUNION key1 [key2]</td>
<td>返回所有给定集合的并集</td>
</tr>
<tr>
<td>SUNIONSTORE destination key1 [key2]</td>
<td>所有给定集合的并集存储在 destination 集合中</td>
</tr>
<tr>
<td>SSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>迭代集合中的元素</td>
</tr>
</tbody></table>
<h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><ul>
<li>sadd/smembers/sismember</li>
<li>scard，获取集合里面的元素个数</li>
<li>srem key value 删除集合中元素</li>
<li>srandmember key 某个整数(随机出几个数)</li>
<li>spop key 随机出栈</li>
<li>smove key1 key2 在key1里某个值 作用是将key1里的某个值赋给key2</li>
<li>数学集合类<ul>
<li>差集：sdiff</li>
<li>交集：sinter</li>
<li>并集：sunion</li>
</ul>
</li>
</ul>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>KV模式不变，但V是一个键值对</p>
<h3 id="常用-3"><a href="#常用-3" class="headerlink" title="常用"></a>常用</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>HDEL key field1 [field2]</td>
<td>删除一个或多个哈希表字段</td>
</tr>
<tr>
<td>HEXISTS key field</td>
<td>查看哈希表 key 中，指定的字段是否存在。</td>
</tr>
<tr>
<td>HGET key field</td>
<td>获取存储在哈希表中指定字段的值。</td>
</tr>
<tr>
<td>HGETALL key</td>
<td>获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td>HINCRBY key field increment</td>
<td>为哈希表 key 中的指定字段的整数值加上增量 increment 。</td>
</tr>
<tr>
<td>HINCRBYFLOAT key field increment</td>
<td>为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td>
</tr>
<tr>
<td>HKEYS key</td>
<td>获取所有哈希表中的字段</td>
</tr>
<tr>
<td>HLEN key</td>
<td>获取哈希表中字段的数量</td>
</tr>
<tr>
<td>HMGET key field1 [field2]</td>
<td>获取所有给定字段的值</td>
</tr>
<tr>
<td>HMSET key field1 value1 [field2 value2 ]</td>
<td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>
</tr>
<tr>
<td>HSET key field value</td>
<td>将哈希表 key 中的字段 field 的值设为 value 。</td>
</tr>
<tr>
<td>HSETNX key field value</td>
<td>只有在字段 field 不存在时，设置哈希表字段的值。</td>
</tr>
<tr>
<td>HVALS key</td>
<td>获取哈希表中所有值。</td>
</tr>
<tr>
<td>HSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>迭代哈希表中的键值对。</td>
</tr>
</tbody></table>
<h3 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h3><ul>
<li>hset/hget/hmset/hmget/hgetall/hdel</li>
<li>hlen</li>
<li>hexists key 在key里面的某个值的key</li>
<li>hkeys/hvals</li>
<li>hincrby/hincrbyfloat</li>
<li>hsetnx</li>
</ul>
<h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><p>在set基础上，加一个score值。 之前set是k1 v1 v2 v3， 现在zset是k1 score1 v1 score2 v2</p>
<h3 id="常用-4"><a href="#常用-4" class="headerlink" title="常用"></a>常用</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ZADD key score1 member1 [score2 member2]</td>
<td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td>ZCARD key</td>
<td>获取有序集合的成员数</td>
</tr>
<tr>
<td>ZCOUNT key min max</td>
<td>计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr>
<td>ZINCRBY key increment member</td>
<td>有序集合中对指定成员的分数加上增量 increment</td>
</tr>
<tr>
<td>ZINTERSTORE destination numkeys key [key …]</td>
<td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td>
</tr>
<tr>
<td>ZLEXCOUNT key min max</td>
<td>在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td>ZRANGE key start stop [WITHSCORES]</td>
<td>通过索引区间返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td>ZRANGEBYLEX key min max [LIMIT offset count]</td>
<td>通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</td>
<td>通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td>ZRANK key member</td>
<td>返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td>ZREM key member [member …]</td>
<td>移除有序集合中的一个或多个成员</td>
</tr>
<tr>
<td>ZREMRANGEBYLEX key min max</td>
<td>移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td>ZREMRANGEBYRANK key start stop</td>
<td>移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td>ZREMRANGEBYSCORE key min max</td>
<td>移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td>ZREVRANGE key start stop [WITHSCORES]</td>
<td>返回有序集中指定区间内的成员，通过索引，分数从高到低</td>
</tr>
<tr>
<td>ZREVRANGEBYSCORE key max min [WITHSCORES]</td>
<td>返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td>ZREVRANK key member</td>
<td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td>ZSCORE key member</td>
<td>返回有序集中，成员的分数值</td>
</tr>
<tr>
<td>ZUNIONSTORE destination numkeys key [key …]</td>
<td>计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
</tr>
<tr>
<td>ZSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody></table>
<h3 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h3><ul>
<li>zadd/zrange<ul>
<li>Withscores</li>
</ul>
</li>
<li>zrangebyscore key 开始score 结束score<ul>
<li>withscores</li>
<li>( 不包含</li>
<li>Limit 作用是返回限制<ul>
<li>limit 开始下标步 多少步</li>
</ul>
</li>
</ul>
</li>
<li>zrem key 某score下对应的value值，作用是删除元素</li>
<li>zcard/zcount key score区间/zrank key values值，作用是获得下标值/zscore key 对应值,获得分数</li>
<li>zrevrank key values值，作用是逆序获得下标值</li>
<li>zrevrange</li>
<li>zrevrangebyscore key 结束score 开始score</li>
</ul>
<h2 id="配置文件介绍"><a href="#配置文件介绍" class="headerlink" title="配置文件介绍"></a>配置文件介绍</h2><p>Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf(Windows 名为 redis.windows.conf)。</p>
<p>你可以通过 CONFIG 命令查看或设置配置项。</p>
<p><strong>语法</strong></p>
<p><code>Redis CONFIG</code> 命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET loglevel</span><br><span class="line"></span><br><span class="line">1) &quot;loglevel&quot;</span><br><span class="line">2) &quot;notice&quot;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>redis.conf 配置项说明如下：</p>
<p><strong>注意</strong>，下面配置项说明并不全，了解更多请检阅redis.conf。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>配置项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>daemonize no</code></td>
<td>Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td>
</tr>
<tr>
<td>2</td>
<td><code>pidfile /var/run/redis.pid</code></td>
<td>当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定</td>
</tr>
<tr>
<td>3</td>
<td><code>port 6379</code></td>
<td>指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</td>
</tr>
<tr>
<td>4</td>
<td><code>bind 127.0.0.1</code></td>
<td>绑定的主机地址</td>
</tr>
<tr>
<td>5</td>
<td><code>timeout 300</code></td>
<td>当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能</td>
</tr>
<tr>
<td>6</td>
<td><code>loglevel notice</code></td>
<td>指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td>
</tr>
<tr>
<td>7</td>
<td><code>logfile stdout</code></td>
<td>日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</td>
</tr>
<tr>
<td>8</td>
<td><code>databases 16</code></td>
<td>设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</td>
</tr>
<tr>
<td>9</td>
<td><code>save &lt;seconds&gt; &lt;changes&gt;</code> Redis 默认配置文件中提供了三个条件： <code>save 900 1</code> <code>save 300 10</code> <code>save 60 10000</code></td>
<td>分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td>
</tr>
<tr>
<td>10</td>
<td><code>rdbcompression yes</code></td>
<td>指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td>
</tr>
<tr>
<td>11</td>
<td><code>dbfilename dump.rdb</code></td>
<td>指定本地数据库文件名，默认值为 dump.rdb</td>
</tr>
<tr>
<td>12</td>
<td><code>dir ./</code></td>
<td>指定本地数据库存放目录</td>
</tr>
<tr>
<td>13</td>
<td><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></td>
<td>设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td>
</tr>
<tr>
<td>14</td>
<td><code>masterauth &lt;master-password&gt;</code></td>
<td>当 master 服务设置了密码保护时，slav 服务连接 master 的密码</td>
</tr>
<tr>
<td>15</td>
<td><code>requirepass foobared</code></td>
<td>设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH 命令提供密码，默认关闭</td>
</tr>
<tr>
<td>16</td>
<td><code>maxclients 128</code></td>
<td>设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td>
</tr>
<tr>
<td>17</td>
<td><code>maxmemory &lt;bytes&gt;</code></td>
<td>指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td>
</tr>
<tr>
<td>18</td>
<td><code>appendonly no</code></td>
<td>指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td>
</tr>
<tr>
<td>19</td>
<td><code>appendfilename appendonly.aof</code></td>
<td>指定更新日志文件名，默认为 appendonly.aof</td>
</tr>
<tr>
<td>20</td>
<td><code>appendfsync everysec</code></td>
<td>指定更新日志条件，共有 3 个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折中，默认值）</td>
</tr>
<tr>
<td>21</td>
<td><code>vm-enabled no</code></td>
<td>指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td>
</tr>
<tr>
<td>22</td>
<td><code>vm-swap-file /tmp/redis.swap</code></td>
<td>虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享</td>
</tr>
<tr>
<td>23</td>
<td><code>vm-max-memory 0</code></td>
<td>将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td>
</tr>
<tr>
<td>24</td>
<td><code>vm-page-size 32</code></td>
<td>Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td>
</tr>
<tr>
<td>25</td>
<td><code>vm-pages 134217728</code></td>
<td>设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td>
</tr>
<tr>
<td>26</td>
<td><code>vm-max-threads 4</code></td>
<td>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</td>
</tr>
<tr>
<td>27</td>
<td><code>glueoutputbuf yes</code></td>
<td>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td>
</tr>
<tr>
<td>28</td>
<td><code>hash-max-zipmap-entries 64</code> <code>hash-max-zipmap-value 512</code></td>
<td>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</td>
</tr>
<tr>
<td>29</td>
<td><code>activerehashing yes</code></td>
<td>指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td>
</tr>
<tr>
<td>30</td>
<td><code>include /path/to/local.conf</code></td>
<td>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</td>
</tr>
</tbody></table>
<h2 id="持久化之RDB"><a href="#持久化之RDB" class="headerlink" title="持久化之RDB"></a>持久化之RDB</h2><p>RDB（Redis DataBase）</p>
<h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</li>
<li>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</li>
</ul>
<blockquote>
<p>Fork</p>
<p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p>
</blockquote>
<ul>
<li>rdb 保存的是dump.rdb文件</li>
<li>相关配置在配置文件的位置 - 在redis.conf搜寻<code>### SNAPSHOTTING ###</code></li>
</ul>
<h3 id="如何触发RDB快照"><a href="#如何触发RDB快照" class="headerlink" title="如何触发RDB快照"></a>如何触发RDB快照</h3><ul>
<li><p>配置文件中默认的快照配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbfilename dump.rdb</span><br></pre></td></tr></table></figure>
<ul>
<li>冷拷贝后重新使用<ul>
<li>可以cp dump.rdb dump_new.rdb</li>
</ul>
</li>
</ul>
</li>
<li><p>命令save或者是bgsave</p>
<ul>
<li>Save：save时只管保存，其它不管，全部阻塞</li>
<li>BGSAVE：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。可以通过lastsave 命令获取最后一次成功执行快照的时间</li>
</ul>
</li>
<li><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p>
</li>
</ul>
<h3 id="如何恢复"><a href="#如何恢复" class="headerlink" title="如何恢复"></a>如何恢复</h3><ul>
<li>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</li>
<li><code>CONFIG GET dir</code>获取目录</li>
</ul>
<h3 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h3><ul>
<li>优势<ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高</li>
</ul>
</li>
<li>劣势<ul>
<li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就 会丢失最后一次快照后的所有修改</li>
<li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li>
</ul>
</li>
</ul>
<h3 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h3><p>动态所有停止RDB保存规则的方法：<code>redis-cli config set save &quot;&quot;</code></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6QZHaR"><img src="https://s3.ax1x.com/2021/03/08/6QZHaR.png" alt="6QZHaR.png" loading="lazy"></a></p>
<ul>
<li>RDB是一个非常紧凑的文件。</li>
<li>RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他I0操作，所以RDB持久化方式可以最大化redis的性能。</li>
<li>与AOF相比，在恢复大的数据集的时候，RDB方式会更快一一些。</li>
<li>数据丢失风险大。</li>
<li>RDB需要经常fork子进程来保存数据集到硬盘上，当数据集比较大的时候fork的过程是非常耗时的吗，可能会导致Redis在一些毫秒级不能回应客户端请求。</li>
</ul>
<h2 id="持久化之AOF"><a href="#持久化之AOF" class="headerlink" title="持久化之AOF"></a>持久化之AOF</h2><p>AOF（Append Only File）</p>
<h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<h3 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h3><ul>
<li>相关配置在配置文件的位置 - 在redis.conf搜寻<code>### APPEND ONLY MODE ###</code></li>
<li>aof保存的是appendonly.aof文件（在配置文件可修改文件名）</li>
</ul>
<h3 id="AOF启动-修复-恢复"><a href="#AOF启动-修复-恢复" class="headerlink" title="AOF启动/修复/恢复"></a>AOF启动/修复/恢复</h3><ul>
<li>正常恢复<ul>
<li>启动：设置Yes<ul>
<li>修改默认的appendonly no，改为yes</li>
</ul>
</li>
<li>将有数据的aof文件复制一份保存到对应目录(config get dir)</li>
<li>恢复：重启redis然后重新加载</li>
</ul>
</li>
<li>异常恢复<ul>
<li>启动：设置Yes<ul>
<li>修改默认的appendonly no，改为yes</li>
</ul>
</li>
<li>备份被写坏的AOF文件</li>
<li>修复：<ul>
<li>Redis-check-aof –fix进行修复</li>
</ul>
</li>
<li>恢复：重启redis然后重新加载</li>
</ul>
</li>
</ul>
<h3 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h3><ul>
<li>是什么：<ul>
<li>AOF采用文件追加方式，文件会越来越大。为避免出现此种情况，新增了重写机制， 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集。可以使用命令bgrewriteaof</li>
</ul>
</li>
<li>重写原理<ul>
<li>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)， 遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件， 而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</li>
</ul>
</li>
<li>触发机制<ul>
<li>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</li>
</ul>
</li>
</ul>
<h3 id="优势与劣势-1"><a href="#优势与劣势-1" class="headerlink" title="优势与劣势"></a>优势与劣势</h3><ul>
<li>优势<ul>
<li>每修改同步：appendfsync always 同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</li>
<li>每秒同步：appendfsync everysec 异步操作，每秒记录 如果一秒内宕机，有数据丢失</li>
<li>不同步：appendfsync no 从不同步</li>
</ul>
</li>
<li>劣势<ul>
<li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li>
<li>Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同</li>
</ul>
</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6QZOG6"><img src="https://s3.ax1x.com/2021/03/08/6QZOG6.png" alt="6QZOG6.png" loading="lazy"></a></p>
<ul>
<li>AOF文件时一个只进行追加的日志文件</li>
<li>Redis可以在AOF文件体积变得过大时，自动地在后台对AOF进行重写</li>
<li>AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，因此AOF文件的内容非常容易被人读懂，对文件进行分析也很轻松</li>
<li>对于相同的数据集来说，AOF文件的体积通常要大于RDB文件的体积</li>
<li>根据所使用的fsync 策略，AOF的速度可能会慢于RDB</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><p>可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞。</p>
<h3 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a>能干嘛</h3><p>一个队列中，一次性、顺序性、排他性的执行一系列命令。</p>
<h3 id="怎么玩-1"><a href="#怎么玩-1" class="headerlink" title="怎么玩"></a>怎么玩</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DISCARD</td>
<td>取消事务，放弃执行事务块内的所有命令。</td>
</tr>
<tr>
<td>EXEC</td>
<td>执行所有事务块内的命令。</td>
</tr>
<tr>
<td>MULTI</td>
<td>标记一个事务块的开始。</td>
</tr>
<tr>
<td>UNWATCH</td>
<td>取消 WATCH 命令对所有 key 的监视。</td>
</tr>
<tr>
<td>WATCH key [key …]</td>
<td>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td>
</tr>
</tbody></table>
<h4 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h4><h5 id="正常执行"><a href="#正常执行" class="headerlink" title="正常执行"></a>正常执行</h5><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6QeFit"><img src="https://s3.ax1x.com/2021/03/08/6QeFit.png" alt="6QeFit.png" loading="lazy"></a></p>
<h5 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h5><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6QeARf"><img src="https://s3.ax1x.com/2021/03/08/6QeARf.png" alt="6QeARf.png" loading="lazy"></a></p>
<h5 id="全体连坐"><a href="#全体连坐" class="headerlink" title="全体连坐"></a>全体连坐</h5><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6QemLQ"><img src="https://s3.ax1x.com/2021/03/08/6QemLQ.png" alt="6QemLQ.png" loading="lazy"></a></p>
<p>类似Java编译异常</p>
<h5 id="冤头债主"><a href="#冤头债主" class="headerlink" title="冤头债主"></a>冤头债主</h5><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6Qe8zT"><img src="https://s3.ax1x.com/2021/03/08/6Qe8zT.png" alt="6Qe8zT.png" loading="lazy"></a></p>
<p>类似Java运行异常</p>
<h5 id="watch监控"><a href="#watch监控" class="headerlink" title="watch监控"></a>watch监控</h5><h6 id="悲观锁-乐观锁-CAS-Check-And-Set"><a href="#悲观锁-乐观锁-CAS-Check-And-Set" class="headerlink" title="悲观锁/乐观锁/CAS(Check And Set)"></a>悲观锁/乐观锁/CAS(Check And Set)</h6><ul>
<li>悲观锁<ul>
<li>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li>
</ul>
</li>
<li>乐观锁<ul>
<li>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。</li>
<li>乐观锁策略:提交版本必须大于记录当前版本才能执行更新</li>
</ul>
</li>
<li>CAS</li>
</ul>
<h6 id="信用卡可用余额和欠额"><a href="#信用卡可用余额和欠额" class="headerlink" title="信用卡可用余额和欠额"></a>信用卡可用余额和欠额</h6><ul>
<li>初始化信用卡可用余额和欠额</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6QeYyF"><img src="https://s3.ax1x.com/2021/03/08/6QeYyF.png" alt="6QeYyF.png" loading="lazy"></a></p>
<ul>
<li>无加塞篡改，先监控再开启multi， 保证两笔金额变动在同一个事务内</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6Qe6yD"><img src="https://s3.ax1x.com/2021/03/08/6Qe6yD.png" alt="6Qe6yD.png" loading="lazy"></a></p>
<ul>
<li>有加塞篡改<ul>
<li>监控了key，<strong>如果key被修改了</strong>，后面一个事务的执行失效</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6QeWTA"><img src="https://s3.ax1x.com/2021/03/08/6QeWTA.png" alt="6QeWTA.png" loading="lazy"></a></p>
<ul>
<li>unwatch</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6QeoSf"><img src="https://s3.ax1x.com/2021/03/08/6QeoSf.png" alt="6QeoSf.png" loading="lazy"></a></p>
<ul>
<li>一旦执行了exec之前加的监控锁都会被取消掉了（一次性）</li>
</ul>
<h6 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h6><ul>
<li>Watch指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变， 比如某个list已被别的客户端push/pop过了，整个事务队列都不会被执行</li>
<li>通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化， EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败</li>
</ul>
<h3 id="3阶段"><a href="#3阶段" class="headerlink" title="3阶段"></a>3阶段</h3><ul>
<li>开启：以MULTI开始一个事务</li>
<li>入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</li>
<li>执行：由EXEC命令触发事务</li>
</ul>
<h3 id="3特性"><a href="#3特性" class="headerlink" title="3特性"></a>3特性</h3><ul>
<li><strong>单独的隔离操作</strong>：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li><strong>没有隔离级别的概念</strong>：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行， 也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题</li>
<li><strong>不保证原子性</strong>：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li>
</ul>
<p>不遵循传统的ACID中的AI</p>
<h2 id="消息订阅发布简介"><a href="#消息订阅发布简介" class="headerlink" title="消息订阅发布简介"></a>消息订阅发布简介</h2><p><strong>用观察者模式理解学习</strong></p>
<p>进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6QeLwj"><img src="https://s3.ax1x.com/2021/03/08/6QeLwj.png" alt="6QeLwj.png" loading="lazy"></a></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6Qm17d"><img src="https://s3.ax1x.com/2021/03/08/6Qm17d.png" alt="6Qm17d.png" loading="lazy"></a></p>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PSUBSCRIBE pattern [pattern …]</td>
<td>订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td>PUBSUB subcommand [argument [argument …]]</td>
<td>查看订阅与发布系统状态。</td>
</tr>
<tr>
<td>PUBLISH channel message</td>
<td>将信息发送到指定的频道。</td>
</tr>
<tr>
<td>PUNSUBSCRIBE [pattern [pattern …]]</td>
<td>退订所有给定模式的频道。</td>
</tr>
<tr>
<td>SUBSCRIBE channel [channel …]</td>
<td>订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td>UNSUBSCRIBE [channel [channel …]]</td>
<td>指退订给定的频道。</td>
</tr>
</tbody></table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat</span><br><span class="line"></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Redis is a great caching technique&quot;</span><br><span class="line"></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Learn redis by runoob.com&quot;</span><br><span class="line"></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 订阅者的客户端会显示如下消息</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) &quot;Redis is a great caching technique&quot;</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) &quot;Learn redis by runoob.com&quot;</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure>
<hr>
<p>订阅多个通配符 *</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PSUBSCRIBE new*</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>收取消息，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH new1 redis2015</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="是什么-4"><a href="#是什么-4" class="headerlink" title="是什么"></a>是什么</h3><p>行话：也就是我们所说的主从复制，主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主</p>
<h3 id="能干嘛-2"><a href="#能干嘛-2" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul>
<li>读写分离</li>
<li>容灾恢复</li>
</ul>
<h3 id="怎么玩-2"><a href="#怎么玩-2" class="headerlink" title="怎么玩"></a>怎么玩</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li><p>配从(库)不配主(库)</p>
</li>
<li><p>从库配置命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 主库IP 主库端口</span><br></pre></td></tr></table></figure>
<ul>
<li>每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件（具体位置：redis.conf搜寻<code>#### REPLICATION ####</code>）</li>
<li><code>info replication</code></li>
</ul>
</li>
<li><p>修改配置文件细节操作</p>
<ul>
<li>拷贝多个redis.conf文件，按’redis[port].conf’重命名</li>
<li>开启daemonize yes</li>
<li>pid文件名字</li>
<li>指定端口</li>
<li>log文件名字</li>
<li>dump.rdb名字</li>
</ul>
</li>
</ul>
<blockquote>
<p>replication<br>英 [ˌreplɪ’keɪʃ(ə)n] 美 [ˌreplɪ’keɪʃ(ə)n]<br>n.<br>(绘画等的)复制;拷贝;重复(实验);(尤指对答辩的)回答</p>
</blockquote>
<h4 id="常用3招"><a href="#常用3招" class="headerlink" title="常用3招"></a>常用3招</h4><h5 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h5><ul>
<li>Init <a target="_blank" rel="noopener" href="https://imgtu.com/i/6Qmb36"><img src="https://s3.ax1x.com/2021/03/08/6Qmb36.png" alt="6Qmb36.png" loading="lazy"></a></li>
<li>一个Master两个Slave <a target="_blank" rel="noopener" href="https://imgtu.com/i/6QngIA"><img src="https://s3.ax1x.com/2021/03/08/6QngIA.png" alt="6QngIA.png" loading="lazy"></a></li>
<li>日志查看<ul>
<li>主机日志 <a target="_blank" rel="noopener" href="https://imgtu.com/i/6QnfRP"><img src="https://s3.ax1x.com/2021/03/08/6QnfRP.png" alt="6QnfRP.png" loading="lazy"></a></li>
<li>备机日志 <a target="_blank" rel="noopener" href="https://imgtu.com/i/6Qnoqg"><img src="https://s3.ax1x.com/2021/03/08/6Qnoqg.png" alt="6Qnoqg.png" loading="lazy"></a></li>
<li><code>info replication</code> <a target="_blank" rel="noopener" href="https://imgtu.com/i/6QuesO"><img src="https://s3.ax1x.com/2021/03/08/6QuesO.png" alt="6QuesO.png" loading="lazy"></a></li>
</ul>
</li>
<li>主从问题演示<ol>
<li>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的123是否也可以复制？<ul>
<li>答：从头开始复制；123也可以复制</li>
</ul>
</li>
<li>从机是否可以写？set可否？<ul>
<li>答：从机不可写，不可set，主机可写</li>
</ul>
</li>
<li>主机shutdown后情况如何？从机是上位还是原地待命<ul>
<li>答：从机还是原地待命（咸鱼翻身，还是咸鱼）</li>
</ul>
</li>
<li>主机又回来了后，主机新增记录，从机还能否顺利复制？<ul>
<li>答：能</li>
</ul>
</li>
<li>其中一台从机down后情况如何？依照原有它能跟上大部队吗？<ul>
<li>答：不能跟上，每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件（具体位置：redis.conf搜寻<code>#### REPLICATION ####</code>）</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011863024/article/details/107476187#">23.</a></p>
<h5 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h5><ul>
<li>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力（奴隶的奴隶还是奴隶）</li>
<li>中途变更转向：会清除之前的数据，重新建立拷贝最新的</li>
<li><code>slaveof 新主库IP 新主库端口</code></li>
</ul>
<h5 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h5><ul>
<li><pre><code>SLAVEOF no one
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 使当前数据库停止与其他数据库的同步，转成主数据库</span><br><span class="line"></span><br><span class="line">### 复制原理</span><br><span class="line"></span><br><span class="line">- slave启动成功连接到master后会发送一个sync命令</span><br><span class="line">- master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</span><br><span class="line">- 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</span><br><span class="line">- 增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</span><br><span class="line">- 但是只要是重新连接master，一次完全同步（全量复制)将被自动执行</span><br><span class="line"></span><br><span class="line">### 哨兵模式(sentinel)</span><br><span class="line"></span><br><span class="line">一组sentinel能同时监控多个master</span><br><span class="line"></span><br><span class="line">#### 是什么</span><br><span class="line"></span><br><span class="line">反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</span><br><span class="line"></span><br><span class="line">#### 怎么玩(使用步骤)</span><br><span class="line"></span><br><span class="line">1. 调整结构，6379带着6380、6381</span><br><span class="line">2. 新建sentinel.conf文件，名字绝不能错</span><br><span class="line">3. 配置哨兵,填写内容</span><br><span class="line">   1. &#96;sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1&#96;</span><br><span class="line">   2. 上面最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机（PS. 跟官网的描述有出入，下面有官方文档说明）</span><br><span class="line">4. 启动哨兵</span><br><span class="line">   1. &#96;redis-sentinel &#x2F;sentinel.conf&#96;（上述目录依照各自的实际情况配置，可能目录不同）</span><br><span class="line">5. 正常主从演示</span><br><span class="line">6. 原有的master挂了</span><br><span class="line">7. 投票新选</span><br><span class="line">8. 重新主从继续开工，info replication查查看</span><br><span class="line"></span><br><span class="line">问题：如果之前挂了的master重启回来，会不会双master冲突？</span><br><span class="line">答： 不会，原master，变成slave</span><br><span class="line"></span><br></pre></td></tr></table></figure>
&gt; sentinel monitor &lt;master-group-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;
&gt; ```
&gt;
&gt; For the sake of clarity, let’s check line by line what the configuration options mean:
&gt;
&gt; The first line is used to tell Redis to monitor a master called mymaster, that is at address 127.0.0.1 and port 6379, with a quorum of 2. Everything is pretty obvious but the **quorum** argument:
&gt;
&gt; - The **quorum** is the number of Sentinels that need to agree about the fact the master is not reachable, in order to really mark the master as failing, and eventually start a failover procedure if possible.
&gt; - However **the quorum is only used to detect the failure**. In order to actually perform a failover, one of the Sentinels need to be elected leader for the failover and be authorized to proceed. This only happens with the vote of the **majority of the Sentinel processes**.
&gt;
&gt; So for example if you have 5 Sentinel processes, and the quorum for a given master set to the value of 2, this is what happens:
&gt;
&gt; - If two Sentinels agree at the same time about the master being unreachable, one of the two will try to start a failover.
&gt; - If there are at least a total of three Sentinels reachable, the failover will be authorized and will actually start.
&gt;
&gt; In practical terms this means during failures **Sentinel never starts a failover if the majority of Sentinel processes are unable to talk** (aka no failover in the minority partition).
&gt;
&gt; [Source](https://redis.io/topics/sentinel/)
</code></pre>
</li>
</ul>
<h3 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h3><p><strong>复制延时</strong></p>
<p>由于所有的写操作都是先在Master上操作，然后同步更新到slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
<h1 id="缓存三大问题及解决方案"><a href="#缓存三大问题及解决方案" class="headerlink" title="缓存三大问题及解决方案"></a>缓存三大问题及解决方案</h1><p>缓存的设计包含很多技巧，设计不当将会导致严重的后果。本文将介绍缓存使用中常见的三大问题，并给出相应的解决方案。</p>
<ul>
<li>缓存穿透</li>
<li>缓存雪崩</li>
<li>缓存击穿</li>
</ul>
<h1 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h1><p>在大多数互联网应用中，缓存的使用方式如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6QuKdH"><img src="https://s3.ax1x.com/2021/03/08/6QuKdH.png" alt="6QuKdH.png" loading="lazy"></a></p>
<ol>
<li>当业务系统发起某一个查询请求时，首先判断缓存中是否有该数据；</li>
<li>如果缓存中存在，则直接返回数据；</li>
<li>如果缓存中不存在，则再查询数据库，然后返回数据。</li>
</ol>
<p>了解了上述过程后，下面说说缓存穿透。</p>
<h2 id="1-1-什么是缓存穿透？"><a href="#1-1-什么是缓存穿透？" class="headerlink" title="1.1 什么是缓存穿透？"></a>1.1 什么是缓存穿透？</h2><p>业务系统要查询的数据根本就存在！当业务系统发起查询时，按照上述流程，首先会前往缓存中查询，由于缓存中不存在，然后再前往数据库中查询。由于该数据压根就不存在，因此数据库也返回空。这就是缓存穿透。</p>
<p>综上所述：业务系统访问压根就不存在的数据，就称为缓存穿透。</p>
<h2 id="1-2-缓存穿透的危害"><a href="#1-2-缓存穿透的危害" class="headerlink" title="1.2 缓存穿透的危害"></a>1.2 缓存穿透的危害</h2><p>如果存在海量请求查询压根就不存在的数据，那么这些海量请求都会落到数据库中，数据库压力剧增，可能会导致系统崩溃（你要知道，目前业务系统中最脆弱的就是IO，稍微来点压力它就会崩溃，所以我们要想种种办法保护它）。</p>
<h2 id="1-3-为什么会发生缓存穿透？"><a href="#1-3-为什么会发生缓存穿透？" class="headerlink" title="1.3 为什么会发生缓存穿透？"></a>1.3 为什么会发生缓存穿透？</h2><p>发生缓存穿透的原因有很多，一般为如下两种：</p>
<ol>
<li>恶意攻击，故意营造大量不存在的数据请求我们的服务，由于缓存中并不存在这些数据，因此海量请求均落在数据库中，从而可能会导致数据库崩溃。</li>
<li>代码逻辑错误。这是程序员的锅，没啥好讲的，开发中一定要避免！</li>
</ol>
<h2 id="1-4-缓存穿透的解决方案"><a href="#1-4-缓存穿透的解决方案" class="headerlink" title="1.4 缓存穿透的解决方案"></a>1.4 缓存穿透的解决方案</h2><p>下面来介绍两种防止缓存穿透的手段。</p>
<h3 id="1-4-1-缓存空数据"><a href="#1-4-1-缓存空数据" class="headerlink" title="1.4.1 缓存空数据"></a>1.4.1 缓存空数据</h3><p>之所以发生缓存穿透，是因为缓存中没有存储这些空数据的key，导致这些请求全都打到数据库上。</p>
<p>那么，我们可以稍微修改一下业务系统的代码，将数据库查询结果为空的key也存储在缓存中。当后续又出现该key的查询请求时，缓存直接返回null，而无需查询数据库。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6QKp1P"><img src="https://s3.ax1x.com/2021/03/08/6QKp1P.jpg" alt="6QKp1P.jpg" loading="lazy"></a></p>
<p>缓存空对象会有两个问题：<br>第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。<br>第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5 分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。</p>
<h3 id="1-4-2-BloomFilter"><a href="#1-4-2-BloomFilter" class="headerlink" title="1.4.2 BloomFilter"></a>1.4.2 BloomFilter</h3><p>第二种避免缓存穿透的方式即为使用BloomFilter。</p>
<p>它需要在缓存之前再加一道屏障，里面存储目前数据库中存在的所有key，如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6QKb3q"><img src="https://s3.ax1x.com/2021/03/08/6QKb3q.png" alt="6QKb3q.png" loading="lazy"></a></p>
<p>当业务系统有查询请求的时候，首先去BloomFilter中查询该key是否存在。若不存在，则说明数据库中也不存在该数据，因此缓存都不要查了，直接返回null。若存在，则继续执行后续的流程，先前往缓存中查询，缓存中没有的话再前往数据库中的查询。</p>
<p>这种方法适用于数据命中不高，数据相对固定实时性低（通常是数据集较大）的应用场景，代码维护较为复杂，但是缓存空间占用少。 </p>
<h3 id="1-4-3-两种方案的比较"><a href="#1-4-3-两种方案的比较" class="headerlink" title="1.4.3 两种方案的比较"></a>1.4.3 两种方案的比较</h3><p>这两种方案都能解决缓存穿透的问题，但使用场景却各不相同。</p>
<p>对于一些恶意攻击，查询的key往往各不相同，而且数据贼多。此时，第一种方案就显得提襟见肘了。因为它需要存储所有空数据的key，而这些恶意攻击的key往往各不相同，而且同一个key往往只请求一次。因此即使缓存了这些空数据的key，由于不再使用第二次，因此也起不了保护数据库的作用。<br>因此，对于<strong>空数据的key各不相同</strong>、<strong>key重复请求概率低</strong>的场景而言，应该选择第二种方案。而对于<strong>空数据的key数量有限</strong>、<strong>key重复请求概率较高</strong>的场景而言，应该选择第一种方案。</p>
<h1 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2. 缓存雪崩"></a>2. 缓存雪崩</h1><h2 id="2-1-什么是缓存雪崩？"><a href="#2-1-什么是缓存雪崩？" class="headerlink" title="2.1 什么是缓存雪崩？"></a>2.1 什么是缓存雪崩？</h2><p>通过上文可知，缓存其实扮演了一个保护数据库的角色。它帮数据库抵挡大量的查询请求，从而避免脆弱的数据库受到伤害。</p>
<p>如果缓存因某种原因发生了宕机，那么原本被缓存抵挡的海量查询请求就会像疯狗一样涌向数据库。此时数据库如果抵挡不了这巨大的压力，它就会崩溃。</p>
<p>这就是缓存雪崩。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6QKqg0"><img src="https://s3.ax1x.com/2021/03/08/6QKqg0.jpg" alt="6QKqg0.jpg" loading="lazy"></a></p>
<h2 id="2-2-如何避免缓存雪崩？"><a href="#2-2-如何避免缓存雪崩？" class="headerlink" title="2.2 如何避免缓存雪崩？"></a>2.2 如何避免缓存雪崩？</h2><h3 id="2-2-1-使用缓存集群，保证缓存高可用"><a href="#2-2-1-使用缓存集群，保证缓存高可用" class="headerlink" title="2.2.1 使用缓存集群，保证缓存高可用"></a>2.2.1 使用缓存集群，保证缓存高可用</h3><p>和飞机都有多个引擎一样，如果缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如前面介绍过的 Redis Sentinel 和 Redis Cluster 都实现了高可用。 </p>
<h3 id="2-2-2-使用Hystrix"><a href="#2-2-2-使用Hystrix" class="headerlink" title="2.2.2 使用Hystrix"></a>2.2.2 使用Hystrix</h3><p>Hystrix是一款开源的“防雪崩工具”，它通过 熔断、降级、限流三个手段来降低雪崩发生后的损失。</p>
<p>Hystrix就是一个Java类库，它采用命令模式，每一项服务处理请求都有各自的处理器。所有的请求都要经过各自的处理器。处理器会记录当前服务的请求失败率。一旦发现当前服务的请求失败率达到预设的值，Hystrix将会拒绝随后该服务的所有请求，直接返回一个预设的结果。这就是所谓的<strong>“熔断”</strong>。当经过一段时间后，Hystrix会放行该服务的一部分请求，再次统计它的请求失败率。如果此时请求失败率符合预设值，则完全打开限流开关；如果请求失败率仍然很高，那么继续拒绝该服务的所有请求。这就是所谓的<strong>“限流”</strong>。而Hystrix向那些被拒绝的请求直接返回一个预设结果，被称为<strong>“降级”</strong>。</p>
<h1 id="3-缓存击穿（热点数据集中失效）"><a href="#3-缓存击穿（热点数据集中失效）" class="headerlink" title="3. 缓存击穿（热点数据集中失效）"></a>3. 缓存击穿（热点数据集中失效）</h1><h2 id="3-1-什么是热点数据集中失效？"><a href="#3-1-什么是热点数据集中失效？" class="headerlink" title="3.1 什么是热点数据集中失效？"></a>3.1 什么是热点数据集中失效？</h2><p>我们一般都会给缓存设定一个失效时间，过了失效时间后，该数据库会被缓存直接删除，从而一定程度上保证数据的实时性。</p>
<p>但是，对于一些请求量极高的热点数据而言，一旦过了有效时间，此刻将会有大量请求落在数据库上，从而可能会导致数据库崩溃。其过程如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6Q8lB6"><img src="https://s3.ax1x.com/2021/03/08/6Q8lB6.jpg" alt="6Q8lB6.jpg" loading="lazy"></a></p>
<p>如果某一个热点数据失效，那么当再次有该数据的查询请求[req-1]时就会前往数据库查询。但是，从请求发往数据库，到该数据更新到缓存中的这段时间中，由于缓存中仍然没有该数据，因此这段时间内到达的查询请求都会落到数据库上，这将会对数据库造成巨大的压力。此外，当这些请求查询完成后，都会重复更新缓存。</p>
<h2 id="3-2-解决方案"><a href="#3-2-解决方案" class="headerlink" title="3.2 解决方案"></a>3.2 解决方案</h2><h3 id="3-2-1-互斥锁"><a href="#3-2-1-互斥锁" class="headerlink" title="3.2.1 互斥锁"></a>3.2.1 互斥锁</h3><p>此方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可，整个过程如图 : </p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6Q84bV"><img src="https://s3.ax1x.com/2021/03/08/6Q84bV.jpg" alt="6Q84bV.jpg" loading="lazy"></a></p>
<p>当第一个数据库查询请求发起后，就将缓存中该数据上锁；此时到达缓存的其他查询请求将无法查询该字段，从而被阻塞等待；当第一个请求完成数据库查询，并将数据更新值缓存后，释放锁；此时其他被阻塞的查询请求将可以直接从缓存中查到该数据。</p>
<p>当某一个热点数据失效后，只有第一个数据库查询请求发往数据库，其余所有的查询请求均被阻塞，从而保护了数据库。但是，由于采用了互斥锁，其他请求将会阻塞等待，此时系统的吞吐量将会下降。这需要结合实际的业务考虑是否允许这么做。</p>
<p>互斥锁可以避免<strong>某一个</strong>热点数据失效导致数据库崩溃的问题，而在实际业务中，往往会存在一批热点数据同时失效的场景。那么，对于这种场景该如何防止数据库过载呢？</p>
<p>设置不同的失效时间</p>
<p>当我们向缓存中存储这些数据的时候，可以将他们的缓存失效时间错开。这样能够避免同时失效。如：在一个基础时间上加/减一个随机数，从而将这些缓存的失效时间错开</p>
<h3 id="3-3-2-永远不过期"><a href="#3-3-2-永远不过期" class="headerlink" title="3.3.2 永远不过期"></a>3.3.2 永远不过期</h3><p>“永远不过期”包含两层意思：<br>从缓存层面来看，确实没有设置过期时间，所以不会出现热点 key 过期后产生的问题，也就是“物理”不过期。<br>从功能层面来看，为每个 value 设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。<br>整个过程如下图所示： </p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6QGp5D"><img src="https://s3.ax1x.com/2021/03/08/6QGp5D.jpg" alt="6QGp5D.jpg" loading="lazy"></a></p>
<p> 从实战看，此方法有效杜绝了热点 key 产生的问题，但唯一不足的就是重构缓存期间，会出现数据不一致的情况，这取决于应用方是否容忍这种不一致。</p>
<h3 id="3-3-3-两种方案的比较"><a href="#3-3-3-两种方案的比较" class="headerlink" title="3.3.3 两种方案的比较"></a>3.3.3 两种方案的比较</h3><ul>
<li>互斥锁 (mutex key)：这种方案思路比较简单，但是存在一定的隐患，如果构建缓存过程出现问题或者时间较长，可能会存在死锁和线程池阻塞的风险，但是这种方法能够较好的降低后端存储负载并在一致性上做的比较好。</li>
<li>” 永远不过期 “：这种方案由于没有设置真正的过期时间，实际上已经不存在热点 key 产生的一系列危害，但是会存在数据不一致的情况，同时代码复杂度会增大。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1oW411u75R">https://www.bilibili.com/video/BV1oW411u75R</a></p>
<p>博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011863024/article/details/107476187">https://blog.csdn.net/u011863024/article/details/107476187</a></p>
<p>博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/haoxin963/article/details/83245113">https://blog.csdn.net/haoxin963/article/details/83245113</a></p>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>XIYUE</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://mikon.github.io/2021/01/23/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="redis学习笔记">http://mikon.github.io/2021/01/23/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/02/14/%E4%BB%8E%E7%AC%AC%E4%B8%80%E5%8F%B0%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E5%99%A8%E5%88%B0%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/" rel="prev" title="从第一台电子计算器到冯诺依曼计算机结构"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">从第一台电子计算器到冯诺依曼计算机结构</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/12/19/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A/" rel="next" title="2020 TECHO PARK 腾讯开发者大会"><span class="post-nav-text">2020 TECHO PARK 腾讯开发者大会</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> XIYUE</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.3.0</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>